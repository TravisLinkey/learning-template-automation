---
title: "Project 2 — Live Paper Trading Bot"
chapter: 0
lesson: 1
author: "Learning Library"
date: "2025-02-08"
description: "Extend the backtesting system into a real-time paper trading bot using broker APIs"
---

# 0.1 — Project 2: Live Paper Trading Bot

Extend your backtesting engine into a real-time trading bot that runs continuously, consumes live market data, generates signals, and places **paper** (simulated) orders via a broker API.

## Objective

Build a bot that runs continuously, generates signals from live data, places paper trades through an API, and tracks performance in real time.

## Focus Areas

- API integration (market data and orders)
- Order execution and lifecycle
- Real-time market data (REST and/or WebSockets)
- Handling market microstructure

## Technologies

- **Python** — Core implementation
- **Alpaca API** or **Interactive Brokers API** — Paper trading and market data
- **WebSockets / REST APIs** — Real-time data and order submission
- **Scheduling and event loops** — Running the bot (e.g., `schedule`, `asyncio`, or a simple loop)

## New Concepts

- **Bid/ask spreads** — Trading at mid vs. crossing the spread
- **Slippage** — Price movement between signal and fill
- **Latency** — Impact of delay on execution quality
- **Order types** — Market, limit, stop; when to use each
- **Risk management** — Position limits, daily loss limits, circuit breakers

## Deliverable

A bot that:

- Runs continuously (or on a schedule) during market hours
- Subscribes to or polls live market data
- Generates signals using logic similar to (or evolved from) your backtester
- Places paper orders via the broker API
- Tracks open positions and P&L in real time
- Logs activity and supports graceful shutdown

---

## Prerequisites (with links to lessons)

| Topic | Why you need it | Where to learn |
|-------|-----------------|----------------|
| **Project 1 — Backtester** | Signal logic and performance mindset | [Project 1: Backtesting Engine](/projects-01-backtester/lessons/0.1) |
| **Python & Pandas** | Data handling, time series | [Python & Pandas](/developer-python-pandas/) |
| **REST / APIs** | Calling broker endpoints | General dev experience; [Networking](/developer-networking/) (stub) for concepts |
| **Concurrency / async** | Event loops, non-blocking I/O | [Concurrency & Multithreading](/developer-concurrency/) (stub) |
| **Probability / risk** | Interpreting live P&L and risk | [Quant Research](/quant/lessons/0.1) |

---

## Steps to Complete the Project

1. **Choose a broker and get paper credentials**  
   Sign up for paper trading with Alpaca or Interactive Brokers. Obtain API keys (and optionally WebSocket URLs). Store credentials in environment variables or a local config file (never commit secrets).

2. **Verify API access**  
   Write a small script to authenticate and fetch account info, then fetch recent quotes or bars for one symbol. Confirm you can read market data and account state.

3. **Design the bot loop**  
   Decide how often to run (e.g., every 1 minute, or event-driven via WebSocket). Implement a main loop that: fetches or receives market data, runs your signal logic, and optionally submits/cancels orders. Handle exceptions and log errors.

4. **Connect your backtester signal logic**  
   Reuse or adapt the indicator and signal code from Project 1. Input: latest bars or quote. Output: desired position or explicit buy/sell/hold. Keep the logic identical at first so you can compare paper results to backtest.

5. **Implement order placement**  
   Translate signals into orders (market or limit). Enforce risk rules (e.g., max position size, one open order at a time). Track order IDs and poll or use callbacks for fill status.

6. **Track positions and P&L**  
   Maintain current positions and cost basis. Update from fills and from periodic account/position API calls. Compute unrealized and realized P&L; log or display in a simple dashboard or file.

7. **Add robustness**  
   Handle disconnects (reconnect WebSocket or retry REST). Add a graceful shutdown (e.g., cancel open orders, flush logs). Consider a daily loss limit or max drawdown check that pauses the bot.

8. **Document and run**  
   README: how to install, configure, and run the bot; how to interpret logs. Run in paper mode for at least a few days and compare behavior to your backtest expectations.

---

## Hints (with backlinks)

- **Paper vs. live** — Use only paper/sim endpoints and paper keys. Double-check that you’re not pointing to live trading. [Quant Research](/quant/) and risk lessons (stub) reinforce the importance of testing before real capital.
- **Idempotency and order state** — Track pending orders so you don’t double-submit. Use order IDs and status from the API to know when to place the next trade. [Concurrency](/developer-concurrency/) (stub) for state and race conditions.
- **Latency and slippage** — In paper mode, fills may be optimistic. Note the timestamp of your signal vs. fill; later you can model slippage. [Networking](/developer-networking/) (stub) for latency concepts.
- **Market hours** — Only trade when the market is open (and optionally avoid first/last minutes). Use the broker’s market-hours API or a known schedule.
- **Logging** — Log every signal, order submit, fill, and position change with timestamps. Makes debugging and comparison to backtest much easier.

---

## Goals

By the end of this project you should be able to:

- Authenticate and use a broker’s paper API for data and orders
- Run a signal loop that consumes live data and places paper orders
- Track positions and P&L in real time
- Handle errors and disconnects and shut down cleanly
- Use this infrastructure as the execution layer for Project 3 (ML strategy)

Next step: [Project 3 — Machine Learning Strategy](/projects-03-ml-trader/lessons/0.1), where you’ll add predictive models and feed their signals into this bot.
