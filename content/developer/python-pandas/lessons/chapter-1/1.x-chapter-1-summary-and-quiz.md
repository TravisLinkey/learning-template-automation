---
title: "Chapter 1 summary and quiz"
chapter: 1
lesson: x
author: "Quant Pandas Team"
date: "2025-02-08"
description: "Summary and quiz for Chapter 1: Data Structures and Time Series"
---

# 1.x — Chapter 1 summary and quiz

## Chapter summary

This chapter covered the pandas fundamentals you need for loading and organizing market data and building a backtest.

### Key concepts

- **Series** and **DataFrame**: one- and two-dimensional structures with labeled indices. For backtesting, use a DataFrame with one row per bar and columns for OHLCV and indicators.
- **Indexing**: `.loc` for labels (dates), `.iloc` for position. Use “past only” slices to avoid look-ahead.
- **DatetimeIndex**: set your index to dates, sort it, use one timezone, and ensure one row per bar.
- **Loading and cleaning**: use yfinance (or similar) to get OHLCV, handle NaNs, normalize timezone, and sort.

### What we learned

1. **1.1 Series and DataFrame**: Create and add columns; keep one row per date and align by index.
2. **1.2 Indexing and selection**: Select columns and rows by label or position; filter with boolean indexing; avoid look-ahead in backtests.
3. **1.3 Time series and DatetimeIndex**: Set and sort a DatetimeIndex; use a single timezone for reliable alignment.
4. **1.4 Loading and cleaning market data**: Download OHLCV with yfinance, drop or fill NaNs, convert timezone, and produce a clean DataFrame.

### Application

These skills directly support [Project 1 — Backtesting Engine](/projects-01-backtester/lessons/0.1): load data (1.4), store in a DataFrame with DatetimeIndex (1.1, 1.3), add indicators and signals (1.1, 1.2), and iterate without look-ahead (1.2).

## Quiz time

**Question 1**

Why should a backtest DataFrame use a DatetimeIndex instead of a default integer index? Show slicing by date with code.

<details>
<summary>Show Solution</summary>

A DatetimeIndex lets you slice by date, keeps columns aligned when you add indicators, and supports resampling. Example:

```python
import pandas as pd

df = pd.DataFrame(
    {'close': [100, 101, 102, 99]},
    index=pd.to_datetime(['2024-01-01', '2024-01-02', '2024-01-03', '2024-01-04'])
)
# Slice by date
h1 = df.loc['2024-01-01':'2024-01-02']
print(h1)
```
</details>

**Question 2**

How do you avoid look-ahead bias when iterating bar-by-bar in a backtest? Write a short loop that, at each bar `i`, uses only past and current data.

<details>
<summary>Show Solution</summary>

At each bar `i`, use `df.iloc[:i+1]` for “all data up to and including the current bar.” Example:

```python
import pandas as pd

df = pd.DataFrame({'close': [10, 11, 12, 13, 14]})
for i in range(1, len(df)):
    past_and_current = df.iloc[:i+1]
    # Compute indicator or signal from past_and_current only
    sma = past_and_current['close'].mean()
    print(f"Bar {i}: sma = {sma}")
```
</details>

**Question 3**

What are two simple ways to handle missing values in OHLCV before backtesting? Show both in code.

<details>
<summary>Show Solution</summary>

(1) Drop rows with any NaN. (2) Forward-fill then drop remaining NaN. Run this:

```python
import pandas as pd

# Example with a NaN
df = pd.DataFrame({'close': [100, float('nan'), 102, 99]})

# Option 1: drop rows with any NaN
clean1 = df.dropna()
print('Option 1 (dropna):\n', clean1)

# Option 2: forward-fill then drop rest (e.g. leading NaN)
df2 = pd.DataFrame({'close': [float('nan'), 101, 102, 99]})
clean2 = df2.ffill().dropna()
print('Option 2 (ffill then dropna):\n', clean2)
```
</details>
