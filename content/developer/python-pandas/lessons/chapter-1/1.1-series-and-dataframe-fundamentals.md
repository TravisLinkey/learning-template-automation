---
title: "Series and DataFrame Fundamentals"
chapter: 1
lesson: 1
author: "Quant Pandas Team"
date: "2025-02-08"
description: "Pandas Series and DataFrame for financial data—essential for backtesting and data manipulation"
---

# 1.1 — Series and DataFrame Fundamentals

Pandas builds on two core structures: **Series** (one-dimensional) and **DataFrame** (two-dimensional). For backtesting and market data, you will almost always work with DataFrames where each row is a timestamp and each column is a price series, indicator, or signal. This lesson gives you what you need to create and manipulate these structures.

> **Used in:** [Project 1 — Backtesting Engine](/projects-01-backtester/lessons/0.1): storing OHLCV data and indicator columns in a DataFrame.

## Series

A **Series** is a one-dimensional labeled array. Labels form the **index**; the values can be any type (often numeric).

```python
import pandas as pd

# Series from a list (default integer index)
prices = pd.Series([100.0, 101.5, 99.2, 102.1])
print(prices)
# 0    100.0
# 1    101.5
# 2     99.2
# 3    102.1

# Series with explicit index (e.g. dates or labels)
prices = pd.Series([100.0, 101.5, 99.2], index=['Mon', 'Tue', 'Wed'])
```

You can do element-wise math and use `.mean()`, `.std()`, `.sum()` etc. Series align by index when you combine them—important when we add indicator columns to a price Series.

## DataFrame

A **DataFrame** is a table: rows and columns, each column a Series sharing the same index. For market data, think **one row per date**, **one column per series** (Open, High, Low, Close, Volume, then your indicators).

```python
# DataFrame from a dict of lists (each key = column name)
df = pd.DataFrame({
    'open':   [100, 101, 99],
    'high':   [102, 103, 100],
    'low':    [98, 100, 97],
    'close':  [101, 102, 99],
})
#    open  high  low  close
# 0   100   102   98    101
# 1   101   103  100    102
# 2    99   100   97     99
```

- **Rows**: default integer index 0, 1, 2. For backtesting you will replace this with a **DatetimeIndex** (see [1.3 — Time series and DatetimeIndex](/developer-python-pandas/lessons/1.3)).
- **Columns**: access with `df['close']` or `df.close` (returns a Series). Add a new column by assignment: `df['sma_10'] = ...`.

## Adding and overwriting columns

You add indicator or signal columns by assigning to a new column name. Pandas aligns by index, so if you assign a Series with a matching index, values line up by date.

```python
df['close_lag1'] = df['close'].shift(1)   # previous day's close
df['returns']    = df['close'].pct_change() # simple daily returns
```

This pattern—one row per date, new columns for indicators and signals—is exactly what you use in a backtest: load OHLCV, then add columns for moving averages, signals, etc.

## Key takeaways for backtesting

- Use a **DataFrame** for your main data: one row per bar (e.g. per day), columns for Open, High, Low, Close, Volume, and any indicators or signals.
- Use a **Series** for a single series (e.g. one symbol’s close, or one indicator) when you need to pass it to a function or compute on it.
- Add columns with assignment (`df['new_col'] = ...`). Keep the same index (dates) so everything stays aligned.

## Quiz time

**Question 1**

What is the difference between a Series and a DataFrame? When would you use each for backtesting?

<details>
<summary>Show Solution</summary>

A **Series** is a one-dimensional labeled array (one index, one value per label). A **DataFrame** is two-dimensional: multiple columns (each a Series) sharing the same index. For backtesting, use a **DataFrame** as your main table—one row per bar, columns for OHLCV and indicators. Use a **Series** when you need a single column or one series to pass to a function.

Try it in a Jupyter cell:

```python
import pandas as pd

# Series: one column of values (e.g. one symbol's close)
close_prices = pd.Series([100, 101, 102, 99], index=['Mon', 'Tue', 'Wed', 'Thu'])
print(close_prices)

# DataFrame: table for backtesting (one row per date, columns for OHLCV + indicators)
df = pd.DataFrame({
    'open':  [100, 101, 102, 99],
    'high':  [102, 103, 104, 101],
    'low':   [98, 100, 101, 97],
    'close': [101, 102, 99, 100],
}, index=['Mon', 'Tue', 'Wed', 'Thu'])
print(df)

# Use a Series when you need one column (e.g. for a function)
close_series = df['close']
print(close_series.mean())
```
</details>

**Question 2**

How do you add a new column to a DataFrame that holds the previous day’s close? What ensures the values line up by date?

<details>
<summary>Show Solution</summary>

Use `df['close_lag1'] = df['close'].shift(1)`. Pandas aligns by **index**, so each row gets the previous row’s close automatically. Full example you can run:

```python
import pandas as pd

df = pd.DataFrame({
    'close': [100, 101, 102, 99, 100],
}, index=['Mon', 'Tue', 'Wed', 'Thu', 'Fri'])

df['close_lag1'] = df['close'].shift(1)
print(df)
# close  close_lag1
# Mon     100         NaN   (no previous day)
# Tue     101       100.0
# Wed     102       101.0
# Thu      99       102.0
# Fri     100        99.0
```
</details>

**Question 3**

Why is “one row per date” and “one column per series” a good shape for backtest data? Build a small example that has that shape.

<details>
<summary>Show Solution</summary>

One row per date matches how time flows when you iterate; one column per series keeps everything aligned by index when you add indicators. Example you can run:

```python
import pandas as pd

# One row per date, one column per series (OHLCV then indicators)
df = pd.DataFrame({
    'open':   [100, 101, 99],
    'high':   [102, 103, 100],
    'low':    [98, 100, 97],
    'close':  [101, 102, 99],
    'volume': [1e6, 1.2e6, 0.9e6],
})
df.index = pd.to_datetime(['2024-01-01', '2024-01-02', '2024-01-03'])
df['returns'] = df['close'].pct_change()
df['sma_2'] = df['close'].rolling(2).mean()
print(df)
```
</details>

## Next steps

In [1.2 — Indexing and selection](/developer-python-pandas/lessons/1.2) we cover how to select rows by date, slice ranges, and select columns. In [1.3 — Time series and DatetimeIndex](/developer-python-pandas/lessons/1.3) we set up a proper date index for backtesting.
