---
title: "Returns and Volatility for Backtesting"
chapter: 1
lesson: 1
author: "Quant Statistics Team"
date: "2025-02-08"
description: "Simple and log returns, volatility, annualization, and Sharpe ratio—what you need for backtest performance metrics"
---

# 1.1 — Returns and Volatility for Backtesting

To evaluate a backtest you need **returns** (how much the strategy gained or lost) and **volatility** (how variable those returns are). This lesson defines simple returns, log returns, volatility, and annualization, and shows how they feed into metrics like the **Sharpe ratio**. This is the statistics foundation for [Project 1 — Backtesting Engine](/projects-01-backtester/lessons/0.1).

## Simple returns

The **simple return** from time $t-1$ to $t$ is:

$$
R_t = \frac{P_t - P_{t-1}}{P_{t-1}} = \frac{P_t}{P_{t-1}} - 1
$$

where $P_t$ is price (or portfolio value) at time $t$. In pandas, for a column of prices:

```python
df['returns'] = df['close'].pct_change()
```

- **Total return** over a period: compound the one-period returns: $(1+R_1)(1+R_2)\cdots(1+R_T) - 1$, or from equity: `(equity[-1] / equity[0]) - 1`.
- **Mean return** (average per period): `returns.mean()`. For annualized return (below), you’ll scale this by the number of periods per year.

## Log returns (optional)

**Log return** is $\ln(P_t / P_{t-1})$. For small returns it’s close to the simple return. Useful for compounding over many periods: the sum of log returns equals the log of the total gross return. In pandas:

```python
import numpy as np
df['log_returns'] = np.log(df['close'] / df['close'].shift(1))
```

For a first backtest, simple returns are enough; use log returns when you need time aggregation or theoretical properties.

## Volatility (standard deviation of returns)

**Volatility** here means the standard deviation of returns. It measures how much returns vary around their average.

- **Sample volatility** (one period, e.g. daily): $\sigma = \sqrt{\frac{1}{n-1}\sum_{t=1}^n (R_t - \bar{R})^2}$. In pandas: `returns.std()`.
- **Annualized volatility**: If you have daily returns and 252 trading days per year, annualized vol is $\sigma_{\text{ann}} = \sigma_{\text{daily}} \times \sqrt{252}$. In code: `returns.std() * np.sqrt(252)`.

Use the same period (e.g. daily) for both returns and volatility when annualizing.

## Annualized return

If $\bar{R}$ is the mean **daily** return:

- **Annualized return** (compound): $(1 + \bar{R})^{252} - 1$ (approximate).
- Or from total return over $T$ days: $(1 + R_{\text{total}})^{252/T} - 1$.

Keep your definition consistent (e.g. 252 business days per year for US equities).

## Sharpe ratio (concept)

The **Sharpe ratio** measures risk-adjusted return. Conceptually:

$$
\text{Sharpe} \approx \frac{\text{Annualized return} - \text{Risk-free rate}}{\text{Annualized volatility}}
$$

- **Risk-free rate**: often a short-term rate (e.g. T-bill). For a simple backtest you can use 0.
- **Interpretation**: Higher Sharpe means more return per unit of volatility. Values often between 0 and 2 for many strategies; negative means the strategy underperformed the risk-free rate.

In code (with risk-free rate = 0 for simplicity):

```python
ann_return = (1 + returns.mean()) ** 252 - 1
ann_vol     = returns.std() * np.sqrt(252)
sharpe      = ann_return / ann_vol if ann_vol > 0 else 0
```

## Summary for backtesting

| Concept | Definition | Pandas / formula |
|--------|------------|------------------|
| Simple return | $(P_t - P_{t-1})/P_{t-1}$ | `df['close'].pct_change()` |
| Total return | From start to end equity | `(equity[-1]/equity[0]) - 1` |
| Volatility | Std dev of returns | `returns.std()` |
| Annualized vol | Scale daily std to year | `returns.std() * np.sqrt(252)` |
| Sharpe (simple) | Return per unit risk | `ann_return / ann_vol` (with 0 risk-free) |

Use these to build your backtest report: total return, annualized return, annualized volatility, and Sharpe ratio. For more on probability and interpreting strategy results, see [Quant Research — Introduction](/quant/lessons/0.1).

## Next steps

Chapter 2 covers hypothesis testing and p-values, which help you ask whether backtest results could be due to chance. For Project 1, returns and volatility are enough to produce a basic performance report.
